# 다이나믹 프로그래밍 1

### 다이나믹 프로그래밍 (Dynamic Programming)

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
- Dynamic Programming의 다이나믹은 아무 의미가 없다.
- 이 용어를 처음 사용한 1940년 Richard Bellman은 멋있어보여서 사용했다고 한다.
- https://en.wikipedia.org/wiki/Dynamic_programming#History
- 동적 계획법
- 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
    - Overlapping Subproblem (겹치는 부분 문제)
    - Optimal Substructure


#### Overlapping Subproblem

- DP 문제 -> 작은 문제, 작은 문제
- 피보나치 수
- F0 = 0
- F1 = 1
- Fn = Fn-1 + Fn-2 (n>=2)

- 문제 : N번째 피보나치 수를 구하는 문제
- 작은 문제 : N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제 

```
Overlapping Subproblem 

문제 : N번째 피보나치 수를 구하는 문제
작은 문제 : N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

문제 : N-1번째 피보나치 수를 구하는 문제
작은 문제 : N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제

문제 : N-2번째 피보나치 수를 구하는 문제
작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제

```

- 큰 문제와 작은 문제는 상대적이다.
- 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
- 문제를 작은 문제로 쪼갤 수 있다. 


#### Optimal Substructure

- 문제의 정답을 작은 문제의 정답에서 구할 수 있다.
- 예시
- 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
- 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다. 

```
Optimal Substructure

문제 : N번째 피보나치 수를 구하는 문제
작은 문제 : N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제
문제의 정답을 작은 문제의 정답을 합하ㅏ는 것으로 구할 수 있다.

문제 : N-1번째 피보나치 수를 구하는 문제
작은 문제 : N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제
문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.

문제 : N-2번째 피보나치 수를 구하는 문제
작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제
문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.
```

- Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
- 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
-  9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
- ...
-  5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
-  4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
-  4번째 피보나치 수는 항상 같다.  


#### 풀이 요령

- 다이나믹 프로그래밍에서 각 문제는 한번만 풀어야 한다.
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
- 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
- 메모를 한다고 해서 영어로 Memoization이라고 한다. 


#### 피보나치 수 

```
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {    // n>=2
        return fibonacci(n-1) + fibonacci(n-2);
    }
}
```

- 피보나치 수를 구하는 함수이다. 
- F0, F1 = 1
- Fn = Fn-1 + Fn-2

- 한번 답을 구할 때, 어딘가에 메모를 해놓고, 중복 호출이면 메모해놓은 값을 리턴한다.
- memo[n] = n번째 피보나치 수

```
int memo[100];
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        if (memo[n] > 0) {
            return memo[n];
        }
        memo[n] = fibonacci(n-1) + fibonacci(n-2);
        return memo[n];
    }
}
```


#### 다이나믹을 푸는 두 가지 방법이 있다.

- Top-down
- Bottom-up


#### Top-down

1. 문제를 작은 문제로 나눈다.
2. 작은 문제를 푼다.
3. 작은 문제를 풀었으니, 이제 문제를 푼다.


- Top-down
    1. 문제를 풀어야 한다.
        - fibonacci(n)
    2. 문제를 작은 문제로 나눈다.
        - fibonacci(n-1)과 fibonacci(n-2)로 문제를 나눈다.
    3. 작은 문제를 푼다.
        - fibonacci(n-1)과 fibonacci(n-2)를 호출해 문제를 푼다.
    4. 작은 문제를 풀었으니, 이제 문제를 푼다.
        - fibonacci(n-1)의 값과 fibonacci(n-2)의 값을 더해 문제를 푼다.
  
- Top-down 은 재귀 호출을 이용해서 문제를 쉽게 풀 수 있다.
- 시간복잡도

```
채워야하는 칸의 (N) x 1칸을 채우는 복잡도 
``` 


#### Bottom-up

1. 문제를 크기가 작은 문제부터 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
4. 그러다보면, 언젠간 풀어야하는 문제를 풀 수 있다.


```
int d[100];
int fibonacci(int n) {
    d[0] = 0;
    d[1] = 1;
    for (int i = 2; i <= n; i++) {  // 제일 작은 문제 ~ <= n
        d[i] = d[i-1] + d[i-2];
    }
    return d[n];
}
```


#### 문제 풀이 전략

- 문제에서 구하려고 하는 답을 문장으로 나타낸다.
- 예: 피보나치 수를 구하는 문제
- N번째 피보나치 수
- 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
- Top-down 인 경우에는 재귀 호출의 인자의 개수
- 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현해야 한다.
- memo[i] = i번째 피보나치 수
- d[i] = i번째 피보나치 수 <---- i-1번째 피보나치 수 (d[i-1]) + i-2번째 피보나치 수 (d[i-2])
- d[i] = d[i-1] + d[i-2]
- dp 